# Справочник языка ЯСНЫЙ

Этот документ описывает актуальное поведение реализации языка ЯСНЫЙ в репозитории.

## 1. Лексика

### 1.1 Ключевые слова

`функция`, `вернуть`, `если`, `иначе`, `пока`, `для`, `в`, `и`, `или`, `не`, `истина`, `ложь`, `пусто`, `пусть`, `подключить`, `из`, `как`, `экспорт`, `прервать`, `продолжить`

### 1.2 Идентификаторы

- Начало: буква Unicode или `_`
- Продолжение: буквы, цифры, `_`

### 1.3 Литералы

- Целые: `10`
- Дробные: `3.14`
- Строки: `"текст"` с escape-последовательностями `\n`, `\t`, `\r`, `\"`, `\\`
- Логические: `истина`, `ложь`
- Пустое значение: `пусто`
- Списки: `[1, 2, 3]`
- Словари: `{ "a": 1, "b": 2 }`

### 1.4 Комментарии

- Однострочные: `# комментарий`

## 2. Блоки и отступы

- Блок начинается после `:`
- Отступы только пробелами
- Табуляция (`TAB`) запрещена
- Парсер использует `INDENT/DEDENT` как в Python

## 3. Типы

### 3.1 Базовые типы

- `Цел`
- `Дроб`
- `Лог`
- `Строка`
- `Пусто`

### 3.2 Параметризованные типы

- `Список[Т]`
- `Словарь[К,З]`

### 3.3 Объединения (union)

- Явная форма: `Цел | Строка`
- Сокращенная nullable-форма: `Строка?` (эквивалент `Строка | Пусто`)

Примеры:

```text
пусть v: Цел | Строка = 10
пусть s: Строка? = пусто
```

### 3.4 Строгая типизация

- Неявных приведений между `Цел` и `Дроб` нет
- `+ - * / %` требуют совместимых числовых типов
- Допускается `Строка + Строка`
- Присваивание проверяется статически до запуска
- `пусть x = expr` выводит тип из `expr`, но не превращает его в `any`

## 4. Операторы и приоритет

Приоритет (сильнее -> слабее):

1. `не`, унарный `-`
2. `* / %`
3. `+ -`
4. `== != < <= > >=`
5. `и`
6. `или`

Логические `и`/`или` в байткоде выполняются с коротким замыканием.

## 5. Выражения

Поддерживаются:

- Идентификаторы: `x`
- Вызовы: `сумма(1, 2)`
- Индексация: `arr[i]`, `словарь[ключ]`, `строка[i]`
- Доступ к члену пространства модуля: `мат.сумма(2, 3)`

`a.b` допустимо только для пространств имен, созданных через `подключить ... как ...`.

## 6. Операторы

### 6.1 Переменные

```text
пусть x = 10
пусть y: Дроб = 3.14
x = 20
```

### 6.2 Функции

```text
функция сумма(a: Цел, b: Цел) -> Цел:
    вернуть a + b
```

- Возвращаемый тип обязателен
- Вложенные функции не поддерживаются
- `main` (если есть) должна быть без параметров и с `-> Пусто`

### 6.3 Условия

```text
если x > 0:
    печать("плюс")
иначе:
    печать("не плюс")
```

### 6.4 Циклы

```text
пока i < 10:
    i = i + 1
```

```text
для x в диапазон(0, 5):
    печать(x)
```

`для` итерируется по `Список[Т]`.

### 6.5 Управление циклом

```text
прервать
продолжить
```

Разрешены только внутри `пока`/`для`.

### 6.6 Индексное присваивание

```text
arr[2] = 99
словарь["k"] = 42
```

## 7. Модули

### 7.1 Формы импорта

Полный импорт в текущую область:

```text
подключить "lib/математика.яс"
```

Полный импорт в namespace:

```text
подключить "lib/математика.яс" как мат
печать(мат.сумма(2, 3))
```

Выборочный импорт:

```text
из "lib/ошибки.яс" подключить ошибка_подключения
```

Выборочный импорт с алиасом:

```text
из "lib/математика.яс" подключить сумма как add
```

### 7.2 Экспорт

```text
экспорт пусть версия: Строка = "1.0"

экспорт функция сумма(a: Цел, b: Цел) -> Цел:
    вернуть a + b
```

Правила:

- Если в модуле нет `экспорт`, действует режим совместимости: экспортируются верхнеуровневые `пусть` и `функция` (кроме `main`)
- Если хотя бы один `экспорт` есть, наружу видны только явно экспортированные объявления
- `main` не экспортируется

### 7.3 Порядок и ограничения

- Импорты должны идти в начале файла, до остальных верхнеуровневых объявлений
- В подключаемом модуле разрешены только верхнеуровневые объявления (`пусть`/`функция`) и импорты
- Циклические импорты запрещены
- Конфликты имен между импортами и локальными объявлениями на верхнем уровне запрещены

### 7.4 Разрешение путей

Резолвер проверяет пути в порядке:

1. Относительно директории текущего файла
2. `modules.root` из `yasn.toml` (если указан)
3. Каждый путь из `modules.paths` в `yasn.toml`

Если расширение не указано, автоматически подставляется `.яс`.

Пример `yasn.toml`:

```toml
[modules]
root = "examples"
paths = ["examples/lib"]
```

## 8. Области видимости

- Есть отдельные области для функции и каждого блока
- Переменная должна быть объявлена до использования
- Повторное `пусть` в том же блоке запрещено
- Переменные верхнего уровня доступны внутри функций (через глобальные слоты VM)

## 9. Встроенные функции

- `печать(...)->Пусто`
- `длина(x)->Цел` для `Строка` и `Список[Т]`
- `диапазон(нач: Цел, конец: Цел)->Список[Цел]`
- `ввод()->Строка`

## 10. Поведение запуска

При `run`/`exec`:

1. Выполняется верхнеуровневый код
2. Если определена `main`, она вызывается автоматически

## 11. Приближенная грамматика (EBNF)

```text
program        = { stmt } ;

stmt           = import_all | import_from
               | export_stmt
               | var_decl | func_decl
               | if_stmt | while_stmt | for_stmt
               | break_stmt | continue_stmt
               | return_stmt | assign_stmt | expr_stmt ;

export_stmt    = "экспорт" (var_decl | func_decl) ;

import_all     = "подключить" string ["как" ident] newline ;
import_from    = "из" string "подключить" import_item { "," import_item } newline ;
import_item    = ident ["как" ident] ;

var_decl       = "пусть" ident [":" type] "=" expr newline ;
assign_stmt    = (ident | index_expr) "=" expr newline ;

func_decl      = "функция" ident "(" [params] ")" "->" type ":" newline
                 indent { stmt } dedent ;
params         = param { "," param } ;
param          = ident ":" type ;

if_stmt        = "если" expr ":" newline indent { stmt } dedent
                 ["иначе" ":" newline indent { stmt } dedent] ;
while_stmt     = "пока" expr ":" newline indent { stmt } dedent ;
for_stmt       = "для" ident "в" expr ":" newline indent { stmt } dedent ;

break_stmt     = "прервать" newline ;
continue_stmt  = "продолжить" newline ;
return_stmt    = "вернуть" expr newline ;
expr_stmt      = expr newline ;

type           = type_atom { "|" type_atom } ;
type_atom      = type_core ["?"] ;
type_core      = prim_type
               | "Список" "[" type "]"
               | "Словарь" "[" type "," type "]"
               | "(" type ")" ;

prim_type      = "Цел" | "Дроб" | "Лог" | "Строка" | "Пусто" ;
```

## 12. Текущие ограничения

- Нет пользовательских структур/классов
- Нет обобщенных функций
- Нет исключений `try/catch`
- Нет официальной стандартной библиотеки модулей, кроме встроенных функций VM
- Нет доступа к файловой системе/сети из самого языка

